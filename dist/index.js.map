{"version":3,"file":"index.js","sources":["../src/Observe.tsx"],"sourcesContent":["import React, { ElementType } from \"react\";\r\n\r\n// Observe component props\r\ninterface IProps {\r\n  options?: IntersectionObserverInit; // Intersection observer options\r\n  triggersOnce?: boolean; // Boolean props which would say if observer must unsubcribe after first isIntersecting event\r\n  as?: ElementType; // Element type which will surround to children props\r\n  // Function that It will be executed every time element is intersecting root element\r\n  isIntersecting?(entry: IntersectionObserverEntry): void;\r\n  // Function that It will be executed every time element is not longer intersecting root element\r\n  isNotIntersecting?(entry: IntersectionObserverEntry): void;\r\n  // Boolean function which it will say if target element will not observe the target element anymore\r\n  unobserve?(entry: IntersectionObserverEntry): boolean;\r\n  onEndObserving?(entry: IntersectionObserverEntry): void;\r\n}\r\n\r\n/**\r\n * Component which will abstract intersection observer behaviour\r\n * @param props\r\n */\r\nconst Observe: React.FC<IProps> = (props) => {\r\n  const {\r\n    as: Component = \"div\",\r\n    children,\r\n    isIntersecting = () => {},\r\n    isNotIntersecting = () => {},\r\n    onEndObserving = () => {},\r\n    options,\r\n    triggersOnce = false,\r\n    unobserve = () => false,\r\n    ...restProps\r\n  } = props;\r\n  /**\r\n   * Reference which will contain element to observe\r\n   */\r\n  const elementRef = React.useRef<HTMLDivElement>(null);\r\n\r\n  /**\r\n   * Callback to listen for changes in element intersection state\r\n   * @param entries\r\n   * @param observer\r\n   */\r\n  function onIntersectionObserverEvent(entries: IntersectionObserverEntry[], observer: IntersectionObserver) {\r\n    const [entry] = entries;\r\n\r\n    if (entry.isIntersecting) {\r\n      isIntersecting(entry);\r\n      // Give a truthy triggersOnce we disconnect observer after first isIntersecting call\r\n      if (triggersOnce) {\r\n        onEndObserving(entry);\r\n        observer.disconnect();\r\n      }\r\n    } else {\r\n      isNotIntersecting(entry);\r\n    }\r\n    // If unobserve function returns true we disconnect observer\r\n    if (unobserve(entry)) {\r\n      onEndObserving(entry);\r\n      observer.disconnect();\r\n    }\r\n  }\r\n\r\n  React.useEffect(() => {\r\n    const observer: IntersectionObserver = new IntersectionObserver(onIntersectionObserverEvent, options);\r\n\r\n    if (elementRef.current) {\r\n      observer.observe(elementRef.current);\r\n    }\r\n    /**\r\n     * Disconnect observer as soon as component unmount\r\n     */\r\n    return () => {\r\n      observer.disconnect();\r\n    };\r\n  }, []);\r\n\r\n  return <Component ref={elementRef} {...restProps}>{children}</Component>;\r\n};\r\n\r\nexport { Observe };\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA;;;;IAIM,OAAO,GAAqB,UAAC,KAAK;IAEpC,IAAA,aAAqB,EAArB,sCAAqB,EACrB,yBAAQ,EACR,yBAAyB,EAAzB,qDAAyB,EACzB,4BAA4B,EAA5B,wDAA4B,EAC5B,yBAAyB,EAAzB,qDAAyB,EACzB,uBAAO,EACP,uBAAoB,EAApB,yCAAoB,EACpB,oBAAuB,EAAvB,8DAAuB,EACvB,8IAAY,CACJ;;;;IAIV,IAAM,UAAU,GAAG,KAAK,CAAC,MAAM,CAAiB,IAAI,CAAC,CAAC;;;;;;IAOtD,SAAS,2BAA2B,CAAC,OAAoC,EAAE,QAA8B;QAChG,IAAA,kBAAK,CAAY;QAExB,IAAI,KAAK,CAAC,cAAc,EAAE;YACxB,cAAc,CAAC,KAAK,CAAC,CAAC;;YAEtB,IAAI,YAAY,EAAE;gBAChB,cAAc,CAAC,KAAK,CAAC,CAAC;gBACtB,QAAQ,CAAC,UAAU,EAAE,CAAC;aACvB;SACF;aAAM;YACL,iBAAiB,CAAC,KAAK,CAAC,CAAC;SAC1B;;QAED,IAAI,SAAS,CAAC,KAAK,CAAC,EAAE;YACpB,cAAc,CAAC,KAAK,CAAC,CAAC;YACtB,QAAQ,CAAC,UAAU,EAAE,CAAC;SACvB;KACF;IAED,KAAK,CAAC,SAAS,CAAC;QACd,IAAM,QAAQ,GAAyB,IAAI,oBAAoB,CAAC,2BAA2B,EAAE,OAAO,CAAC,CAAC;QAEtG,IAAI,UAAU,CAAC,OAAO,EAAE;YACtB,QAAQ,CAAC,OAAO,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;SACtC;;;;QAID,OAAO;YACL,QAAQ,CAAC,UAAU,EAAE,CAAC;SACvB,CAAC;KACH,EAAE,EAAE,CAAC,CAAC;IAEP,OAAO,oBAAC,SAAS,aAAC,GAAG,EAAE,UAAU,IAAM,SAAS,GAAG,QAAQ,CAAa,CAAC;AAC3E;;;;"}